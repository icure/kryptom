package com.icure.kryptom.crypto.external

import com.icure.kryptom.utils.unsafeUuidFromRandomBytes

external interface PartialXStrongRandom {
	/**
	 * Generates a sequence of random bytes.
	 * @param length amount of bytes to generate
	 * @return the generated bytes.
	 */
	fun randomBytes(length: Int): ByteArray
}

external interface XStrongRandom : PartialXStrongRandom {
	/**
	 * Generates a random UUID.
	 * @return string representation of the uuid.
	 */
	fun randomUUID(): String

	/**
	 * Fills an array with random content.
	 */
	fun fill(array: ByteArray)
}

fun completePartialStrongRandom(partialService: PartialXStrongRandom): XStrongRandom {
	val partialDynamic: dynamic = partialService
	if (
		partialDynamic.fill != undefined && partialDynamic.randomUUID != undefined
	) return partialDynamic
	val fullService = js("{}")
	fullService.randomBytes = partialDynamic.randomBytes
	if (
		partialDynamic.fill != undefined
	) {
		fullService.fill = partialDynamic.fill
	} else {
		fullService.fill = fun (array: ByteArray): Unit {
			val randoms = partialService.randomBytes(array.size)
			randoms.copyInto(array)
		}
	}
	if (
		partialDynamic.randomUUID != undefined
	) {
		fullService.randomUUID = partialDynamic.randomUUID
	} else {
		@OptIn(ExperimentalUnsignedTypes::class)
		fullService.randomUUID = fun (): String {
			return unsafeUuidFromRandomBytes(partialService.randomBytes(16).asUByteArray())
		}
	}
	return fullService
}