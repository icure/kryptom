package com.icure.kryptom.crypto.external

import com.icure.kryptom.crypto.AesAlgorithm
import com.icure.kryptom.crypto.AesKey
import com.icure.kryptom.crypto.AesService.Companion.IV_BYTE_LENGTH
import kotlin.js.Promise

@JsExport
external interface XAesService {
	/**
	 * Generates a new aes key of the specified size (128 bits by default)
	 * @param size size of the key in bits.
	 * @return the generated key.
	 */
	fun generateKey(algorithm: String, size: Int): Promise<XAesKey>

	/**
	 * Converts an aes key into a byte array. The output can be used with [loadKey]
	 * @param key the key to convert
	 * @return a representation of the key as a byte array.
	 */
	fun exportKey(key: XAesKey): Promise<ByteArray>

	/**
	 * Loads an aes keys from a byte array. The byte array must have a size compatible with valid aes keys size.
	 * @param bytes the byte representation of the aes key.
	 * @return the loaded key.
	 */
	fun loadKey(algorithm: String, bytes: ByteArray): Promise<XAesKey>

	/**
	 * Encrypts data using the provided key. The encryption algorithm is AES cbc with PKCS7 padding.
	 * @param data the data to encrypt.
	 * @param key the key to use for encryption.
	 * @param iv (optional) an initialization vector. If not provided a new one will be generated by the implementation.
	 * @return an array consisting of the concatenation of the initialization vector and the encrypted data.
	 * @throws IllegalArgumentException if the key is invalid (for example if the size is not good for an aes key) or if
	 * the initialization vector is not null and has a length different from [IV_BYTE_LENGTH]
	 */
	fun encrypt(data: ByteArray, key: XAesKey, iv: ByteArray?): Promise<ByteArray>

	/**
	 * Decrypts data which was encrypted with AES cbc with PKCS7 padding.
	 *
	 * ## Decryption with wrong key
	 *
	 * If the provided key is not the correct one the decryption may fail with an exception or may simply return an
	 * array of junk. Some implementations may never throw an error while others may only sometimes throw an error.
	 * There is no way of knowing with 100% accuracy if the provided key was correct, unless the decrypted data is
	 * expected to have a certain structure, in which case the caller may verify the correctness of the result.
	 *
	 * TLDR:
	 * - If the method throws an exception the provided key is wrong
	 * - If the method returns something either the provided key may be the correct key but may also not, in which case
	 * the returned result is just junk.
	 *
	 * @param ivAndEncryptedData an array consisting of the concatenation of the initialization vector and the encrypted
	 * data.
	 * @param key the key to use for decryption.
	 * @return the decrypted data.
	 * @throws IllegalArgumentException if the key is invalid (for example if the size is not good for an aes key).
	 */
	fun decrypt(ivAndEncryptedData: ByteArray, key: XAesKey): Promise<ByteArray>
}

@JsExport
data class XAesKey(
	val key: dynamic,
	val algorithm: String
)

internal fun <A : AesAlgorithm> XAesKey.toKryptom(algorithm: A): AesKey<A> {
	if (this.algorithm != algorithm.identifier) {
		throw AssertionError("Algorithm mismatch: ${this.algorithm} != ${algorithm.identifier}")
	}
	return AesKey(key, algorithm)
}

internal fun AesKey<*>.toExternal(): XAesKey = XAesKey(cryptoKey, algorithm.identifier)